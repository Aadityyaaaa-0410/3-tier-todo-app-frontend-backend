name: Blue-Green Deploy React App to S3

on:
  push:
    branches:
      - master
    paths:
      - 'frontend/**'

jobs:
  deploy:
    runs-on: self-hosted
    permissions:
      contents: read
    defaults:
      run:
        working-directory: ./frontend

    steps:
      # ------------------------------------------------------------
      # 1. Checkout & Build
      # ------------------------------------------------------------
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '25'

      - name: Install & Build
        run: |
          npm ci
          npm run build

      # ------------------------------------------------------------
      # 2. Validate Required Secrets
      # ------------------------------------------------------------
      - name: Validate Required Secrets
        run: |
          MISSING=()
          [[ -z "${{ secrets.S3_BUCKET_NAME_NEW }}" ]] && MISSING+=("S3_BUCKET_NAME_NEW (Green bucket)")
          [[ -z "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]] && MISSING+=("CLOUDFRONT_DISTRIBUTION_ID")
          [[ -z "${{ secrets.CLOUDFRONT_URL }}" ]] && MISSING+=("CLOUDFRONT_URL")
          [[ -z "${{ secrets.AWS_REGION }}" ]] && MISSING+=("AWS_REGION")

          if (( ${#MISSING[@]} )); then
            echo "ERROR: Missing required secrets:"
            for s in "${MISSING[@]}"; do echo " - $s"; done
            echo "Add them in: Settings → Secrets and variables → Actions"
            exit 1
          fi
          echo "All required secrets are present"

      # ------------------------------------------------------------
      # 3. Deploy to GREEN S3 Bucket
      # ------------------------------------------------------------
      - name: Deploy to Green S3 Bucket
        env:
          GREEN_BUCKET: ${{ secrets.S3_BUCKET_NAME_NEW }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Deploying build to GREEN bucket: $GREEN_BUCKET"
          aws s3 sync dist/ "s3://$GREEN_BUCKET" --delete --region "$AWS_REGION"
          echo "Deployment to GREEN bucket complete"

      # ------------------------------------------------------------
      # 4. Get current CloudFront config (ETag + current origin)
      # ------------------------------------------------------------
      - name: Get current CloudFront config
        id: cf
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          echo "Fetching CloudFront distribution config..."
          aws cloudfront get-distribution-config --id "$DIST_ID" > cf-full.json

          # Extract ETag
          ETAG=$(jq -r .ETag cf-full.json)
          echo "etag=$ETAG" >> $GITHUB_OUTPUT

          # Extract DistributionConfig (required for update)
          jq '.DistributionConfig' cf-full.json > cf-config.json

          # Get current target origin
          CURRENT=$(jq -r '.DefaultCacheBehavior.TargetOriginId' cf-config.json)
          echo "current_origin=$CURRENT" >> $GITHUB_OUTPUT

          # Debug: show all origins
          echo "Available origins in distribution:"
          jq -r '.Origins.Items[] | " - \(.Id) → \(.DomainName)"' cf-config.json

      # ------------------------------------------------------------
      # 5. Switch to the OTHER origin (assumes exactly 2 origins)
      # ------------------------------------------------------------
      - name: Switch CloudFront to other origin
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          # Read both origin IDs
          mapfile -t ORIGINS < <(jq -r '.Origins.Items[].Id' cf-config.json)

          if (( ${#ORIGINS[@]} != 2 )); then
            echo "ERROR: Expected exactly 2 origins, found ${#ORIGINS[@]}"
            echo "Origins found:"
            printf ' - %s\n' "${ORIGINS[@]}"
            exit 1
          fi

          echo "Origin 1: ${ORIGINS[0]}"
          echo "Origin 2: ${ORIGINS[1]}"

          # Determine which one to switch to
          CURRENT="${{ steps.cf.outputs.current_origin }}"
          if [[ "$CURRENT" == "${ORIGINS[0]}" ]]; then
            NEW_ID="${ORIGINS[1]}"
            echo "Currently using ${ORIGINS[0]} → switching to ${ORIGINS[1]} (GREEN)"
          else
            NEW_ID="${ORIGINS[0]}"
            echo "Currently using ${ORIGINS[1]} → switching to ${ORIGINS[0]} (GREEN)"
          fi

          # Update config
          jq --arg id "$NEW_ID" \
            '.DefaultCacheBehavior.TargetOriginId = $id' \
            cf-config.json > cf-updated.json

          # Apply change
          aws cloudfront update-distribution \
            --id "$DIST_ID" \
            --distribution-config file://cf-updated.json \
            --if-match "${{ steps.cf.outputs.etag }}"

          echo "CloudFront now pointing to origin: $NEW_ID"
          echo "new_origin=$NEW_ID" >> $GITHUB_OUTPUT

      # ------------------------------------------------------------
      # 6. Invalidate CloudFront Cache
      # ------------------------------------------------------------
      - name: Invalidate CloudFront Cache
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          echo "Creating CloudFront invalidation..."
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DIST_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          echo "Invalidation created: $INVALIDATION_ID"

      # ------------------------------------------------------------
      # 7. Health Check (wait for 200 OK)
      # ------------------------------------------------------------
      - name: Health Check
        id: health
        env:
          URL: ${{ secrets.CLOUDFRONT_URL }}
        run: |
          echo "Waiting 30s for CloudFront propagation..."
          sleep 30

          MAX_RETRIES=6
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$URL")
            echo "→ HTTP $HTTP_CODE"

            if [[ "$HTTP_CODE" -eq 200 ]]; then
              echo "Health check passed!"
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi

            [[ $i -lt $MAX_RETRIES ]] && sleep 15
          done

          echo "Health check failed after $MAX_RETRIES attempts"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1

      # ------------------------------------------------------------
      # 8. Rollback on failure
      # ------------------------------------------------------------
      - name: Rollback to previous origin
        if: steps.health.outputs.status == 'failed'
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          echo "ROLLBACK: Health check failed. Reverting to original origin..."

          # Re-fetch fresh config
          aws cloudfront get-distribution-config --id "$DIST_ID" > rb-full.json
          ETAG=$(jq -r .ETag rb-full.json)
          jq '.DistributionConfig' rb-full.json > rb-config.json

          # Restore original origin
          ORIGINAL_ID="${{ steps.cf.outputs.current_origin }}"
          echo "Rolling back to origin: $ORIGINAL_ID"

          jq --arg id "$ORIGINAL_ID" \
            '.DefaultCacheBehavior.TargetOriginId = $id' \
            rb-config.json > rb-updated.json

          aws cloudfront update-distribution \
            --id "$DIST_ID" \
            --distribution-config file://rb-updated.json \
            --if-match "$ETAG"

          # Invalidate again
          aws cloudfront create-invalidation \
            --distribution-id "$DIST_ID" \
            --paths "/*" > /dev/null

          echo "Rollback complete. Serving from original origin: $ORIGINAL_ID"
          echo "Deployment FAILED and was rolled back."

      # ------------------------------------------------------------
      # 9. Success Message
      # ------------------------------------------------------------
      - name: Deployment Success
        if: steps.health.outputs.status == 'success'
        run: |
          echo "Deployment SUCCESSFUL!"
          echo "Production is now served from the GREEN bucket"
          echo "CloudFront origin: ${{ steps.switch.outputs.new_origin }}"
          echo "View live: ${{ secrets.CLOUDFRONT_URL }}"
